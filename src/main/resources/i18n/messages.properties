app.name=Kafkador
broker.documentation.node.id=The node ID associated with the roles this process is playing whenprocess.rolesis non-empty.This is required configuration when running in KRaft mode.
broker.documentation.process.roles=The roles that this process plays: ‘broker’, ‘controller’, or ‘broker,controller’ if it is both.
broker.documentation.add.partitions.to.txn.retry.backoff.max.ms=The maximum allowed timeout for adding partitions to transactions on the server side.It only applies to the actual add partition operations, not the verification.It will not be effective if it is larger than request.timeout.ms
broker.documentation.add.partitions.to.txn.retry.backoff.ms=The server-side retry backoff when the server attempts to add the partition to the transaction
broker.documentation.advertised.listeners=Specifies the listener addresses that the Kafka brokers will advertise to clients and other brokers.The config is useful where the actual listener configurationlistenersdoes not represent the addresses that clients should use to connect, such as in cloud environments.The addresses are published to and managed by the controller, the brokers pull these data from the controller as needed.In IaaS environments, this may need to be different from the interface to which the broker binds.If this is not set, the value forlistenerswill be used.Unlikelisteners, it is not valid to advertise the 0.0.0.0 meta-address.Also unlikelisteners, there can be duplicated ports in this property, so that one listener can be configured to advertise another listener’s address.This can be useful in some cases where external load balancers are used.
broker.documentation.auto.create.topics.enable=Enable auto creation of topic on the server.
broker.documentation.auto.leader.rebalance.enable=Enables auto leader balancing.A background thread checks the distribution of partition leaders at regular intervals, configurable by leader.imbalance.check.interval.seconds.If the leader is imbalanced, leader rebalance to the preferred leader for partitions is triggered.
broker.documentation.background.threads=The number of threads to use for various background processing tasks
broker.documentation.broker.id=The broker id for this server.
broker.documentation.compression.type=Specify the final compression type for a given topic.This configuration accepts the standard compression codecs (‘gzip’, ‘snappy’, ‘lz4’, ‘zstd’).It additionally accepts ‘uncompressed’ which is equivalent to no compression; and ‘producer’ which means retain the original compression codec set by the producer.
broker.documentation.confluent.balancer.consumer.out.max.bytes.per.second=This config specifies the upper capacity limit for consumer outgoing bytes per second per leader broker.The Confluent DataBalancer will attempt to keep outgoing data throughput below this limit.Note that fetch from follower traffic is not accounted for in this first release.
broker.documentation.confluent.balancer.disk.max.load=This config specifies the maximum load for disk usage as a proportion of disk capacity.Valid values are between 0 and 1.
broker.documentation.confluent.balancer.enable=This config controls whether the balancer is enabled
broker.documentation.confluent.balancer.heal.broker.failure.threshold.ms=This config specifies how long the balancer will wait after detecting a broker failure before triggering a balancing action.-1 means that broker failures will not trigger balancing actions
broker.documentation.confluent.balancer.heal.uneven.load.trigger=Controls what causes the Confluent DataBalancer to start rebalance operations.Acceptable values are ANY_UNEVEN_LOAD and EMPTY_BROKER
broker.documentation.confluent.balancer.max.replicas=The replica capacity is the maximum number of replicas the balancer will place on a single broker.
broker.documentation.confluent.balancer.network.in.max.bytes.per.second=This config specifies the upper capacity limit for network incoming bytes per second per broker.The Confluent DataBalancer will attempt to keep incoming data throughput below this limit.
broker.documentation.confluent.balancer.network.out.max.bytes.per.second=This config specifies the upper capacity limit for network outgoing bytes per second per broker.The Confluent DataBalancer will attempt to keep outgoing data throughput below this limit.
broker.documentation.confluent.balancer.producer.in.max.bytes.per.second=This config specifies the upper capacity limit for producer incoming bytes per second per broker.The Confluent DataBalancer will attempt to keep incoming data throughput below this limit.
broker.documentation.confluent.balancer.replication.in.max.bytes.per.second=This config specifies the upper capacity limit for replication incoming bytes per second per broker.The Confluent DataBalancer will attempt to keep incoming data throughput below this limit.
broker.documentation.confluent.balancer.throttle.bytes.per.second=This config specifies the upper bound for bandwidth in bytes to move replicas around for replica reassignment.A value of -1 disables throttling entirely.
broker.documentation.confluent.offsets.log.cleaner.delete.retention.ms=The delete retention timeout for the log cleaner compacting the __consumer_offsets topic.
broker.documentation.confluent.offsets.log.cleaner.max.compaction.lag.ms=The maximum time a message will remain ineligible for compaction in the log.Only applicable for __consumer_offsets logs that are being compacted.
broker.documentation.confluent.offsets.log.cleaner.min.cleanable.dirty.ratio=The minimum cleanable dirty ratio config for the __consumer_offsets topic.
broker.documentation.confluent.offsets.topic.placement.constraints=This configuration is a JSON object that controls the set of brokers (replicas) which will always be allowed to join the ISR.And the set of brokers (observers) which are not allowed to join the ISR.The format of JSON is:{  “version”: 1,  “replicas”: [    {      “count”: 2,      “constraints”: {“rack”: “east-1”}    },    {      “count”: 1,      “constraints”: {“rack”: “east-2”}    }  ],  “observers”:[    {      “count”: 1,      “constraints”: {“rack”: “west-1”}    }  ]}
broker.documentation.confluent.security.event.logger.authentication.enable=Enable authentication audit logs
broker.documentation.confluent.security.event.logger.enable=Whether the event logger is enabled
broker.documentation.confluent.tier.azure.block.blob.container=The Azure Block Blob Container to use for tiered storage.
broker.documentation.confluent.tier.azure.block.blob.cred.file.path=The path to the credentials file used to create the Azure Block Blob client.It uses a JSON file with one of the following options:-connectionStringfor the targetconfluent.tier.azure.block.blob.container.-azureClientId,azureTenantIdandazureClientSecretfor the targetconfluent.tier.azure.block.blob.container.Please refer to Azure documentation for further information.If this property is not specified, the Azure Block Blob client will use theDefaultAzureCredentialto locate the credentials across several well-known locations.
broker.documentation.confluent.tier.azure.block.blob.endpoint=The Azure Storage Account endpoint, in the format ofhttps://{accountName}.blob.core.windows.net.
broker.documentation.confluent.tier.azure.block.blob.prefix=This prefix will be added to tiered storage objects stored in the target Azure Block Blob Container.
broker.documentation.confluent.tier.gcs.bucket=The GCS bucket to use for tiered storage.
broker.documentation.confluent.tier.gcs.prefix=This prefix will be added to tiered storage objects stored in GCS.
broker.documentation.confluent.tier.gcs.region=The GCS region to use for tiered storage.
broker.documentation.confluent.tier.local.hotset.bytes=When tiering is enabled, this configuration controls the maximum size a partition (which consists of log segments) can grow to on broker-local storage before we will discard old log segments to free up space.Log segments retained on broker-local storage is referred as the “hotset”.Segments discarded from local store could continue to exist in tiered storage and remain available for fetches depending on retention configurations.By default there is no size limit only a time limit.Since this limit is enforced at the partition level, multiply it by the number of partitions to compute the topic hotset in bytes.
broker.documentation.confluent.tier.local.hotset.ms=When tiering is enabled, this configuration controls the maximum time we will retain a log segment on broker-local storage before we will discard it to free up space.Segments discarded from local store could continue to exist in tiered storage and remain available for fetches depending on retention configurations.If set to -1, no time limit is applied.
broker.documentation.confluent.tier.metadata.replication.factor=The replication factor for the tier metadata topic (set higher to ensure availability).
broker.documentation.confluent.tier.s3.bucket=The S3 bucket to use for tiered storage.
broker.documentation.confluent.tier.s3.prefix=This prefix will be added to tiered storage objects stored in S3.
broker.documentation.confluent.tier.s3.region=The S3 region to use for tiered storage.
broker.documentation.confluent.tier.s3.sse.algorithm=The S3 server side encryption algorithm to use to protect objects at rest.Currently supports AES256, aws:kms, and none.Defaults to AES256.
broker.documentation.confluent.transaction.state.log.placement.constraints=This configuration is a JSON object that controls the set of brokers (replicas) which will always be allowed to join the ISR.And the set of brokers (observers) which are not allowed to join the ISR.The format of JSON is:{  “version”: 1,  “replicas”: [    {      “count”: 2,      “constraints”: {“rack”: “east-1”}    },    {      “count”: 1,      “constraints”: {“rack”: “east-2”}    }  ],  “observers”:[    {      “count”: 1,      “constraints”: {“rack”: “west-1”}    }  ]}
broker.documentation.controller.listener.names=A comma-separated list of the names of the listeners used by the controller.This is required when communicating with the controller quorum, the broker will always use the first listener in this list.
broker.documentation.controller.quorum.bootstrap.servers=List of endpoints to use for bootstrapping the cluster metadata.The endpoints are specified in comma-separated list of{host}:{port}entries.For example:localhost:9092,localhost:9093,localhost:9094.
broker.documentation.controller.quorum.election.backoff.max.ms=Maximum time in milliseconds before starting new elections.This is used in the binary exponential backoff mechanism that helps prevent gridlocked elections
broker.documentation.controller.quorum.election.timeout.ms=Maximum time in milliseconds to wait without being able to fetch from the leader before triggering a new election
broker.documentation.controller.quorum.fetch.timeout.ms=Maximum time without a successful fetch from the current leader before becoming a candidate and triggering an election for voters; Maximum time a leader can go without receiving valid fetch or fetchSnapshot request from a majority of the quorum before resigning.
broker.documentation.controller.quorum.voters=Map of id/endpoint information for the set of voters in a comma-separated list of{id}@{host}:{port}entries.For example:1@localhost:9092,2@localhost:9093,3@localhost:9094
broker.documentation.delete.topic.enable=Enables delete topic.Delete topic through the admin tool will have no effect if this config is turned off
broker.documentation.early.start.listeners=A comma-separated list of listener names which may be started before the authorizer has finished initialization.This is useful when the authorizer is dependent on the cluster itself for bootstrapping, as is the case for the StandardAuthorizer (which stores ACLs in the metadata log.) By default, all listeners included in controller.listener.names will also be early start listeners.A listener should not appear in this list if it accepts external traffic.
broker.documentation.group.coordinator.threads=The number of threads used by the group coordinator.
broker.documentation.leader.imbalance.check.interval.seconds=The frequency with which the partition rebalance check is triggered by the controller
broker.documentation.listeners=Listener List - Comma-separated list of URIs we will listen on and the listener names.If the listener name is not a security protocol,listener.security.protocol.mapmust also be set.Listener names and port numbers must be unique unless one listener is an IPv4 address and the other listener is an IPv6 address (for the same port).Specify hostname as 0.0.0.0 to bind to all interfaces.Leave hostname empty to bind to default interface.Examples of legal listener lists:PLAINTEXT://myhost:9092,SSL://:9091CLIENT://0.0.0.0:9092,REPLICATION://localhost:9093PLAINTEXT://127.0.0.1:9092,SSL://[::1]:9092
broker.documentation.log.dir=The directory in which the log data is kept (supplemental for log.dirs property)
broker.documentation.log.dirs=A comma-separated list of the directories where the log data is stored.If not set, the value in log.dir is used.
broker.documentation.log.flush.interval.messages=The number of messages accumulated on a log partition before messages are flushed to disk.
broker.documentation.log.flush.interval.ms=The maximum time in ms that a message in any topic is kept in memory before flushed to disk.If not set, the value in log.flush.scheduler.interval.ms is used
broker.documentation.log.flush.offset.checkpoint.interval.ms=The frequency with which we update the persistent record of the last flush which acts as the log recovery point.
broker.documentation.log.flush.scheduler.interval.ms=The frequency in ms that the log flusher checks whether any log needs to be flushed to disk
broker.documentation.log.flush.start.offset.checkpoint.interval.ms=The frequency with which we update the persistent record of log start offset
broker.documentation.log.retention.bytes=The maximum size of the log before deleting it
broker.documentation.log.retention.hours=The number of hours to keep a log file before deleting it (in hours), tertiary to log.retention.ms property
broker.documentation.log.retention.minutes=The number of minutes to keep a log file before deleting it (in minutes), secondary to log.retention.ms property.If not set, the value in log.retention.hours is used
broker.documentation.log.retention.ms=The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used.If set to -1, no time limit is applied.
broker.documentation.log.roll.hours=The maximum time before a new log segment is rolled out (in hours), secondary to log.roll.ms property
broker.documentation.log.roll.jitter.hours=The maximum jitter to subtract from logRollTimeMillis (in hours), secondary to log.roll.jitter.ms property
broker.documentation.log.roll.jitter.ms=The maximum jitter to subtract from logRollTimeMillis (in milliseconds).If not set, the value in log.roll.jitter.hours is used
broker.documentation.log.roll.ms=The maximum time before a new log segment is rolled out (in milliseconds).If not set, the value in log.roll.hours is used
broker.documentation.log.segment.bytes=The maximum size of a single log file
broker.documentation.log.segment.delete.delay.ms=The amount of time to wait before deleting a file from the filesystem.If the value is 0 and there is no file to delete, the system will wait 1 millisecond.Low value will cause busy waiting
broker.documentation.message.max.bytes=The largest record batch size allowed by Kafka (after compression if compression is enabled).If this is increased and there are consumers older than 0.10.2, the consumers’ fetch size must also be increased so that they can fetch record batches this large.In the latest message format version, records are always grouped into batches for efficiency.In previous message format versions, uncompressed records are not grouped into batches and this limit only applies to a single record in that case.This can be set per topic with the topic levelmax.message.bytesconfig.
broker.documentation.metadata.log.dir=This configuration determines where we put the metadata log.If it is not set, the metadata log is placed in the first log directory from log.dirs.
broker.documentation.metadata.log.max.record.bytes.between.snapshots=This is the maximum number of bytes in the log between the latest snapshot and the high-watermark needed before generating a new snapshot.The default value is 20971520.To generate snapshots based on the time elapsed, see themetadata.log.max.snapshot.interval.msconfiguration.The Kafka node will generate a snapshot when either the maximum time interval is reached or the maximum bytes limit is reached.
broker.documentation.metadata.log.max.snapshot.interval.ms=This is the maximum number of milliseconds to wait to generate a snapshot if there are committed records in the log that are not included in the latest snapshot.A value of zero disables time based snapshot generation.The default value is 3600000.To generate snapshots based on the number of metadata bytes, see themetadata.log.max.record.bytes.between.snapshotsconfiguration.The Kafka node will generate a snapshot when either the maximum time interval is reached or the maximum bytes limit is reached.
broker.documentation.metadata.log.segment.bytes=The maximum size of a single metadata log file.
broker.documentation.metadata.log.segment.ms=The maximum time before a new metadata log file is rolled out (in milliseconds).
broker.documentation.metadata.max.retention.bytes=The maximum combined size of the metadata log and snapshots before deleting old snapshots and log files.Since at least one snapshot must exist before any logs can be deleted, this is a soft limit.
broker.documentation.metadata.max.retention.ms=The number of milliseconds to keep a metadata log file or snapshot before deleting it.Since at least one snapshot must exist before any logs can be deleted, this is a soft limit.
broker.documentation.min.insync.replicas=When a producer sets acks to “all” (or “-1”), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful.If this minimum cannot be met, then the producer will raise an exception (eitherNotEnoughReplicasorNotEnoughReplicasAfterAppend).Regardless of theackssetting, the messages will not be visible to the consumers until they are replicated to all in-sync replicas and themin.insync.replicascondition is met.When used together,min.insync.replicasandacksallow you to enforce greater durability guarantees.A typical scenario would be to create a topic with a replication factor of 3, setmin.insync.replicasto 2, and produce withacksof “all”.This will ensure that a majority of replicas must persist a write before it’s considered successful by the producer and it’s visible to consumers.
broker.documentation.num.io.threads=The number of threads that the server uses for processing requests, which may include disk I/O
broker.documentation.num.network.threads=The number of threads that the server uses for receiving requests from the network and sending responses to the network.Noted: each listener (except for controller listener) creates its own thread pool.
broker.documentation.num.recovery.threads.per.data.dir=The number of threads per data directory to be used for log recovery at startup and flushing at shutdown
broker.documentation.num.replica.alter.log.dirs.threads=The number of threads that can move replicas between log directories, which may include disk I/O.The default value is equal to the number of directories specified in thelog.dirorlog.dirsconfiguration property.
broker.documentation.num.replica.fetchers=Number of fetcher threads used to replicate records from each source broker.The total number of fetchers on each broker is bound bynum.replica.fetchersmultiplied by the number of brokers in the cluster.Increasing this value can increase the degree of I/O parallelism in the follower and leader broker at the cost of higher CPU and memory utilization.
broker.documentation.offset.metadata.max.bytes=The maximum size for a metadata entry associated with an offset commit.
broker.documentation.offsets.commit.timeout.ms=Offset commit will be delayed until all replicas for the offsets topic receive the commit or this timeout is reached.This is similar to the producer request timeout.This is applied to all the writes made by the coordinator.
broker.documentation.offsets.load.buffer.size=Batch size for reading from the offsets segments when loading group metadata  into the cache (soft-limit, overridden if records are too large).
broker.documentation.offsets.retention.check.interval.ms=Frequency at which to check for stale offsets
broker.documentation.offsets.retention.minutes=For subscribed consumers, committed offset of a specific partition will be expired and discarded when 1) this retention period has elapsed after the consumer group loses all its consumers (i.e.becomes empty); 2) this retention period has elapsed since the last time an offset is committed for the partition and the group is no longer subscribed to the corresponding topic.For standalone consumers (using manual assignment), offsets will be expired after this retention period has elapsed since the time of last commit.Note that when a group is deleted via the delete-group request, its committed offsets will also be deleted without extra retention period; also when a topic is deleted via the delete-topic request, upon propagated metadata update any group’s committed offsets for that topic will also be deleted without extra retention period.
broker.documentation.offsets.topic.compression.codec=Compression codec for the offsets topic - compression may be used to achieve “atomic” commits.
broker.documentation.offsets.topic.num.partitions=The number of partitions for the offset commit topic (should not change after deployment).
broker.documentation.offsets.topic.replication.factor=The replication factor for the offsets topic (set higher to ensure availability).Internal topic creation will fail until the cluster size meets this replication factor requirement.
broker.documentation.offsets.topic.segment.bytes=The offsets topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads.
broker.documentation.queued.max.requests=The number of queued requests allowed for data-plane, before blocking the network threads
broker.documentation.replica.fetch.min.bytes=Minimum bytes expected for each fetch response.If not enough bytes, wait up toreplica.fetch.wait.max.ms(broker config).
broker.documentation.replica.fetch.wait.max.ms=The maximum wait time for each fetcher request issued by follower replicas.This value should always be less than the replica.lag.time.max.ms at all times to prevent frequent shrinking of ISR for low throughput topics
broker.documentation.replica.high.watermark.checkpoint.interval.ms=The frequency with which the high watermark is saved out to disk
broker.documentation.replica.lag.time.max.ms=If a follower hasn’t sent any fetch requests or hasn’t consumed up to the leader’s log end offset for at least this time, the leader will remove the follower from ISR
broker.documentation.replica.socket.receive.buffer.bytes=The socket receive buffer for network requests to the leader for replicating data
broker.documentation.replica.socket.timeout.ms=The socket timeout for network requests.Its value should be at least replica.fetch.wait.max.ms
broker.documentation.request.timeout.ms=The configuration controls the maximum amount of time the client will wait for the response of a request.If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.
broker.documentation.sasl.mechanism.controller.protocol=SASL mechanism used for communication with controllers.Default is GSSAPI.
broker.documentation.share.coordinator.load.buffer.size=Batch size for reading from the share-group state topic when loading state information into the cache (soft-limit, overridden if records are too large).
broker.documentation.share.coordinator.state.topic.compression.codec=Compression codec for the share-group state topic.
broker.documentation.share.coordinator.state.topic.min.isr=Overridden min.insync.replicas for the share-group state topic.
broker.documentation.share.coordinator.state.topic.num.partitions=The number of partitions for the share-group state topic (should not change after deployment).
broker.documentation.share.coordinator.state.topic.replication.factor=Replication factor for the share-group state topic.Topic creation will fail until the cluster size meets this replication factor requirement.
broker.documentation.share.coordinator.state.topic.segment.bytes=The log segment size for the share-group state topic.
broker.documentation.share.coordinator.write.timeout.ms=The duration in milliseconds that the share coordinator will wait for all replicas of the share-group state topic to receive a write.
broker.documentation.socket.receive.buffer.bytes=The SO_RCVBUF buffer of the socket server sockets.If the value is -1, the OS default will be used.
broker.documentation.socket.request.max.bytes=The maximum number of bytes in a socket request
broker.documentation.socket.send.buffer.bytes=The SO_SNDBUF buffer of the socket server sockets.If the value is -1, the OS default will be used.
broker.documentation.transaction.max.timeout.ms=The maximum allowed timeout for transactions.If a client?s requested transaction time exceed this, then the broker will return an error in InitProducerIdRequest.This prevents a client from too large of a timeout, which can stall consumers reading from topics included in the transaction.
broker.documentation.transaction.state.log.load.buffer.size=Batch size for reading from the transaction log segments when loading producer ids and transactions into the cache (soft-limit, overridden if records are too large).
broker.documentation.transaction.state.log.min.isr=The minimum number of replicas that must acknowledge a write to transaction topic in order to be considered successful.
broker.documentation.transaction.state.log.num.partitions=The number of partitions for the transaction topic (should not change after deployment).
broker.documentation.transaction.state.log.replication.factor=The replication factor for the transaction topic (set higher to ensure availability).Internal topic creation will fail until the cluster size meets this replication factor requirement.
broker.documentation.transaction.state.log.segment.bytes=The transaction topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads
broker.documentation.transactional.id.expiration.ms=The time in ms that the transaction coordinator will wait without receiving any transaction status updates for the current transaction before expiring its transactional id.Transactional IDs will not expire while a the transaction is still ongoing.
broker.documentation.unclean.leader.election.enable=Indicates whether to enable replicas not in the ISR set to be elected as leader as a last resort, even though doing so may result in data loss
broker.documentation.broker.heartbeat.interval.ms=The length of time in milliseconds between broker heartbeats.
broker.documentation.broker.rack=Rack of the broker.This will be used in rack aware replication assignment for fault tolerance.Examples:RACK1,us-east-1d
broker.documentation.broker.session.timeout.ms=The length of time in milliseconds that a broker lease lasts if no heartbeats are made.
broker.documentation.compression.gzip.level=The compression level to use if compression.type is set to ‘gzip’.
broker.documentation.compression.lz4.level=The compression level to use if compression.type is set to ‘lz4’.
broker.documentation.compression.zstd.level=The compression level to use if compression.type is set to ‘zstd’.
broker.documentation.confluent.balancer.capacity.threshold.upper.limit=Upper limit on capacity threshold config.If balancing fail with original capacity thresholds defined for each resource, SBC will try to bump it up to this limit (maybe in multiple stages) and try to balance again.Balancing will fail only if capacity threshold is set to this value and brokers can’t be balanced.
broker.documentation.confluent.balancer.disk.min.free.space.gb=The minimum amount of disk space, in GB, that needs to remain unused on a broker.Valid values are between 0 and disk size.The balancer will enforce the stricter bound between this config and ‘confluent.balancer.disk.max.load’.
broker.documentation.confluent.balancer.disk.min.free.space.lower.limit.gb=The lower limit on minimum amount of free disk space, in gigabytes, that needs to remain unused on a broker.On failing to balance, SBC will reset the min disk space config DISK_CAPACITY_MIN_FREE_SPACE_CONFIG to this value and will try to balance again.The balancer will enforce the stricter bound between this config and ‘confluent.balancer.disk.max.load’.
broker.documentation.confluent.balancer.exclude.topic.names=This config accepts a list of topic names that will be excluded from rebalancing.For example, ‘confluent.balancer.exclude.topic.names=[topic1, topic2]’
broker.documentation.confluent.balancer.exclude.topic.prefixes=This config accepts a list of topic prefixes that will be excluded from rebalancing.For example, ‘confluent.balancer.exclude.topic.prefixes=[prefix1, prefix2]’ would exclude topics ‘prefix1-suffix1’, ‘prefix1-suffix2’, ‘prefix2-suffix3’, but not ‘abc-prefix1-xyz’ and ‘def-prefix2’
broker.documentation.confluent.cluster.link.allow.config.providers=Allow cluster link to use config providers to resolve the cluster link configurations.
broker.documentation.confluent.cluster.link.enable=Enable cluster linking feature.
broker.documentation.confluent.cluster.link.fetch.response.min.bytes=Minimum fetch response size used by cluster link fetchers in the default pool if the total size is limited by ‘confluent.cluster.link.fetch.response.total.bytes’.
broker.documentation.confluent.cluster.link.fetch.response.total.bytes=Maximum amount of data fetched by all cluster link fetchers in the default fetcher pool in a broker.If total ‘replica.fetch.response.max.bytes’ for all fetchers in the default pool on the broker exceeds this value, all cluster link fetchers reduce their response size to meet this limit.Minimum value for each fetcher can be configured using ‘confluent.cluster.link.fetch.response.min.bytes’.
broker.documentation.confluent.cluster.link.io.max.bytes.per.second=A long value representing the upper bound (bytes/sec) on throughput for cluster link replication.It is suggested that the limit be kept above 1MB/s for accurate behaviour.
broker.documentation.confluent.cluster.link.metadata.topic.create.retry.delay.ms=The retry delay in milliseconds when the attempt to create cluster linking metadata topic is failed
broker.documentation.confluent.cluster.link.metadata.topic.enable=Whether the cluster link metadata topic should be created and used.The leader of each of this topic’s partitions can run asynchronous tasks across multiple links.This is used to distribute work for the tasks across the links, instead of running all tasks on the Kafka Controller.This config is only relevant for ZK mode in cases where there are multiple cluster links, and must be set prior to migrating to KRaft.In KRaft mode, this config is always true.
broker.documentation.confluent.cluster.link.metadata.topic.min.isr=The minimum number of in sync replicas for the cluster linking metadata topic
broker.documentation.confluent.cluster.link.metadata.topic.partitions=Number of partitions for the cluster linking metadata topic
broker.documentation.confluent.cluster.link.metadata.topic.replication.factor=Replication factor the for the cluster linking metadata topic
broker.documentation.confluent.cluster.link.replication.quota.mode.per.tenant.overrides=A comma-separated list of per-tenant overrides to the default cluster link quota mode.An example value is “lkc-abcd:CLUSTER_LINK_ONLY”,”lkc-efgh:TOTAL_INBOUND”
broker.documentation.confluent.group.metadata.load.threads=The number of threads group metadata load / unload can use to concurrently load / unload metadata.
broker.documentation.confluent.log.cleaner.timestamp.validation.enable=When enabled, this configuration enables timestamp validation checks for created records.Otherwise, skips the timestamp validation check.Defaults to true.
broker.documentation.confluent.replica.fetch.backoff.max.ms=The maximum amount of time in milliseconds to wait when fetch partition fails repeatedly.If provided, the backoff will increase exponentially for each consecutive failure, up to this maximum.
broker.documentation.confluent.request.pipelining.enable=Setting this configuration to true enables the broker to process multiple in-flight produce requests per connection.
broker.documentation.confluent.request.pipelining.max.in.flight.requests.per.connection=This configures the maximum number of in-flight requests per connection if request pipelining is enabled.
broker.documentation.confluent.share.metadata.load.threads=The number of threads share metadata load / unload can use to concurrently load / unload metadata.
broker.documentation.confluent.tier.archiver.num.threads=The size of the thread pool used for tiering data to remote storage.This thread pool is also used to garbage collect data in tiered storage that has been deleted.
broker.documentation.confluent.tier.backend=Tiered storage backend to use
broker.documentation.confluent.tier.cleaner.enable=Enables tiering and tiered cleaning of compacted topics.If disabled, tiering for those topics will be disabled and topics will be cleaned by local log cleaner.
broker.documentation.confluent.tier.cleaner.feature.enable=Feature flag that enables tiered cleaning components.This must be enabled before tiered cleaning could be enabled by usingconfluent.tier.cleaner.enableproperty.This configuration is not reversible and will apply to all non-internal metadata topics.
broker.documentation.confluent.tier.cleaner.min.cleanable.ratio=The minimum ratio of dirty log to total log for a tiered log to eligible for cleaning if the conditions for confluent.tier.cleaner.min.cleanable.ratio have not been met.
broker.documentation.confluent.tier.enable=Allow tiering for topic(s).This enables tiering and fetching of data to and from the configured remote storage.When set to true, this causes all existing, non-compacted topics to also have this configuration set to true.Only topics explicitly set tofalsewill remain false.It is not required to set confluent.tier.enable=true to enable Tiered Storage.
broker.documentation.confluent.tier.feature=Feature flag that enables components related to tiered storage.This must be enabled before tiering could be enabled by usingconfluent.tier.enableproperty.
broker.documentation.confluent.tier.fetcher.num.threads=The size of the thread pool used by the TierFetcher.Roughly corresponds to number of concurrent fetch requests that can be served from tiered storage.
broker.documentation.confluent.tier.max.partition.fetch.bytes.override=For tier fetches, this configuration allows overriding the consumer’smax.partition.fetch.bytesconfiguration.When fetching tiered data, we will use the maximum of the consumer’s configuration and this override.Setting this to a value higher than that of the consumer’s could improve batching and effective throughput of tiered fetches.The override is disabled when set to 0.
broker.documentation.confluent.tier.metadata.bootstrap.servers=The bootstrap servers used to read from and write to the tier metadata topic.If this is not configured, the configured inter-broker listener would be used.
broker.documentation.connections.max.idle.ms=Idle connections timeout: the server socket processor threads close the connections that idle more than this
broker.documentation.connections.max.reauth.ms=When explicitly set to a positive number (the default is 0, not a positive number), a session lifetime that will not exceed the configured value will be communicated to v2.2.0 or later clients when they authenticate.The broker will disconnect any such connection that is not re-authenticated within the session lifetime and that is then subsequently used for any purpose other than re-authentication.Configuration names can optionally be prefixed with listener prefix and SASL mechanism name in lower-case.For example, listener.name.sasl_ssl.oauthbearer.connections.max.reauth.ms=3600000
broker.documentation.controlled.shutdown.enable=Enable controlled shutdown of the server.
broker.documentation.controller.quorum.append.linger.ms=The duration in milliseconds that the leader will wait for writes to accumulate before flushing them to disk.
broker.documentation.controller.quorum.request.timeout.ms=The configuration controls the maximum amount of time the client will wait for the response of a request.If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.
broker.documentation.controller.socket.timeout.ms=The socket timeout for controller-to-broker channels.
broker.documentation.default.replication.factor=The replication factor for automatically created topics, and for topics created with -1 as the replication factor
broker.documentation.delegation.token.expiry.time.ms=The token validity time in milliseconds before the token needs to be renewed.Default value 1 day.
broker.documentation.delegation.token.max.lifetime.ms=The token has a maximum lifetime beyond which it cannot be renewed anymore.Default value 7 days.
broker.documentation.delegation.token.secret.key=Secret key to generate and verify delegation tokens.The same key must be configured across all the brokers. If using Kafka with KRaft, the key must also be set across all controllers. If the key is not set or set to empty string, brokers will disable the delegation token support.
broker.documentation.delete.records.purgatory.purge.interval.requests=The purge interval (in number of requests) of the delete records request purgatory
broker.documentation.fetch.max.bytes=The maximum number of bytes we will return for a fetch request.Must be at least 1024.
broker.documentation.fetch.purgatory.purge.interval.requests=The purge interval (in number of requests) of the fetch request purgatory
broker.documentation.group.consumer.assignors=The server side assignors as a list of either names for builtin assignors or full class names for customer assignors.The first one in the list is considered as the default assignor to be used in the case where the consumer does not specify an assignor.The supported builtin assignors are: uniform, range.
broker.documentation.group.consumer.heartbeat.interval.ms=The heartbeat interval given to the members of a consumer group.
broker.documentation.group.consumer.max.heartbeat.interval.ms=The maximum heartbeat interval for registered consumers.
broker.documentation.group.consumer.max.session.timeout.ms=The maximum allowed session timeout for registered consumers.
broker.documentation.group.consumer.max.size=The maximum number of consumers that a single consumer group can accommodate.This value will only impact groups under the CONSUMER group protocol.To configure the max group size when using the CLASSIC group protocol use group.max.size instead.
broker.documentation.group.consumer.migration.policy=The config that enables converting the non-empty classic group using the consumer embedded protocol to the non-empty consumer group using the consumer group protocol and vice versa; conversions of empty groups in both directions are always enabled regardless of this policy.bidirectional: both upgrade from classic group to consumer group and downgrade from consumer group to classic group are enabled, upgrade: only upgrade from classic group to consumer group is enabled, downgrade: only downgrade from consumer group to classic group is enabled, disabled: neither upgrade nor downgrade is enabled.
broker.documentation.group.consumer.min.heartbeat.interval.ms=The minimum heartbeat interval for registered consumers.
broker.documentation.group.consumer.min.session.timeout.ms=The minimum allowed session timeout for registered consumers.
broker.documentation.group.consumer.session.timeout.ms=The timeout to detect client failures when using the consumer group protocol.
broker.documentation.group.coordinator.append.linger.ms=The duration in milliseconds that the coordinator will wait for writes to accumulate before flushing them to disk.Transactional writes are not accumulated.
broker.documentation.group.coordinator.rebalance.protocols=The list of enabled rebalance protocols.The share rebalance protocol is in early access and therefore must not be used in production.
broker.documentation.group.initial.rebalance.delay.ms=The amount of time the group coordinator will wait for more consumers to join a new group before performing the first rebalance.A longer delay means potentially fewer rebalances, but increases the time until processing begins.
broker.documentation.group.max.session.timeout.ms=The maximum allowed session timeout for registered consumers.Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.
broker.documentation.group.max.size=The maximum number of consumers that a single consumer group can accommodate.
broker.documentation.group.min.session.timeout.ms=The minimum allowed session timeout for registered consumers.Shorter timeouts result in quicker failure detection at the cost of more frequent consumer heartbeating, which can overwhelm broker resources.
broker.documentation.group.share.delivery.count.limit=The maximum number of delivery attempts for a record delivered to a share group.
broker.documentation.group.share.heartbeat.interval.ms=The heartbeat interval given to the members of a share group.
broker.documentation.group.share.max.groups=The maximum number of share groups.
broker.documentation.group.share.max.heartbeat.interval.ms=The maximum heartbeat interval for share group members.
broker.documentation.group.share.max.record.lock.duration.ms=The record acquisition lock maximum duration in milliseconds for share groups.
broker.documentation.group.share.max.session.timeout.ms=The maximum allowed session timeout for share group members.
broker.documentation.group.share.max.size=The maximum number of members that a single share group can accommodate.
broker.documentation.group.share.min.heartbeat.interval.ms=The minimum heartbeat interval for share group members.
broker.documentation.group.share.min.record.lock.duration.ms=The record acquisition lock minimum duration in milliseconds for share groups.
broker.documentation.group.share.min.session.timeout.ms=The minimum allowed session timeout for share group members.
broker.documentation.group.share.partition.max.record.locks=Share-group record lock limit per share-partition.
broker.documentation.group.share.record.lock.duration.ms=The record acquisition lock duration in milliseconds for share groups.
broker.documentation.group.share.session.timeout.ms=The timeout to detect client failures when using the share group protocol.
broker.documentation.initial.broker.registration.timeout.ms=When initially registering with the controller quorum, the number of milliseconds to wait before declaring failure and exiting the broker process.
broker.documentation.inter.broker.listener.name=Name of listener used for communication between brokers.If this is unset, the listener name is defined by security.inter.broker.protocol.It is an error to set this and security.inter.broker.protocol properties at the same time.
broker.documentation.log.cleaner.backoff.ms=The amount of time to sleep when there are no logs to clean
broker.documentation.log.cleaner.dedupe.buffer.size=The total memory used for log deduplication across all cleaner threads
broker.documentation.log.cleaner.delete.retention.ms=The amount of time to retain tombstone message markers for log compacted topics.This setting also gives a bound on the time in which a consumer must complete a read if they begin from offset 0 to ensure that they get a valid snapshot of the final stage (otherwise  tombstones messages may be collected before a consumer completes their scan).
broker.documentation.log.cleaner.enable=Enable the log cleaner process to run on the server.Should be enabled if using any topics with a cleanup.policy=compact including the internal offsets topic.If disabled those topics will not be compacted and continually grow in size.
broker.documentation.log.cleaner.io.buffer.load.factor=Log cleaner dedupe buffer load factor.The percentage full the dedupe buffer can become.A higher value will allow more log to be cleaned at once but will lead to more hash collisions
broker.documentation.log.cleaner.io.buffer.size=The total memory used for log cleaner I/O buffers across all cleaner threads
broker.documentation.log.cleaner.io.max.bytes.per.second=The log cleaner will be throttled so that the sum of its read and write i/o will be less than this value on average
broker.documentation.log.cleaner.max.compaction.lag.ms=The maximum time a message will remain ineligible for compaction in the log.Only applicable for logs that are being compacted.
broker.documentation.log.cleaner.min.cleanable.ratio=The minimum ratio of dirty log to total log for a log to eligible for cleaning.If the log.cleaner.max.compaction.lag.ms or the log.cleaner.min.compaction.lag.ms configurations are also specified, then the log compactor considers the log eligible for compaction as soon as either: (i) the dirty ratio threshold has been met and the log has had dirty (uncompacted) records for at least the log.cleaner.min.compaction.lag.ms duration, or (ii) if the log has had dirty (uncompacted) records for at most the log.cleaner.max.compaction.lag.ms period.
broker.documentation.log.cleaner.min.compaction.lag.ms=The minimum time a message will remain uncompacted in the log.Only applicable for logs that are being compacted.
broker.documentation.log.cleaner.threads=The number of background threads to use for log cleaning
broker.documentation.log.cleanup.policy=The default cleanup policy for segments beyond the retention window.A comma separated list of valid policies.
broker.documentation.log.cleanup.policy.empty.validation=The behavior whencleanup.policyis found to be empty.It can one ofnoneorlog.When set tolog, an error message will be logged whencleanup.policyis found to be empty for a topic.
broker.documentation.log.deletion.max.segments.per.run=The maximum eligible segments that can be deleted during every check.
broker.documentation.log.deletion.throttler.disk.free.headroom.bytes=The headroom for the disk space available (in bytes) that will be added toconfluent.backpressure.disk.free.threshold.bytes (if enabled) to determine the threshold for the minimum available disk space across all the log dirs.This configuration acts as a safety net enabling the broker to reclaim disk space quickly when the broker’s available disk space is running low.When the available disk space is below the threshold value, the broker auto disables the effect oflog.deletion.max.segments.per.run and deletes all eligible segments during periodic retention.When the available disk space is at or above the threshold, the broker auto enables the effect of log.deletion.max.segments.per.run.
broker.documentation.log.index.interval.bytes=The interval with which we add an entry to the offset index.
broker.documentation.log.index.size.max.bytes=The maximum size in bytes of the offset index
broker.documentation.log.message.timestamp.after.max.ms=This configuration sets the allowable timestamp difference between the message timestamp and the broker’s timestamp.The message timestamp can be later than or equal to the broker’s timestamp, with the maximum allowable difference determined by the value set in this configuration.If log.message.timestamp.type=CreateTime, the message will be rejected if the difference in timestamps exceeds this specified threshold.This configuration is ignored if log.message.timestamp.type=LogAppendTime.
broker.documentation.log.message.timestamp.before.max.ms=This configuration sets the allowable timestamp difference between the broker’s timestamp and the message timestamp.The message timestamp can be earlier than or equal to the broker’s timestamp, with the maximum allowable difference determined by the value set in this configuration.If log.message.timestamp.type=CreateTime, the message will be rejected if the difference in timestamps exceeds this specified threshold.This configuration is ignored if log.message.timestamp.type=LogAppendTime.
broker.documentation.log.message.timestamp.type=Define whether the timestamp in the message is message create time or log append time.The value should be eitherCreateTimeorLogAppendTime.
broker.documentation.log.preallocate=Should pre allocate file when create new segment? If you are using Kafka on Windows, you probably need to set it to true.
broker.documentation.log.retention.check.interval.ms=The frequency in milliseconds that the log cleaner checks whether any log is eligible for deletion
broker.documentation.max.connection.creation.rate=The maximum connection creation rate we allow in the broker at any time.Listener-level limits may also be configured by prefixing the config name with the listener prefix, for example,listener.name.internal.max.connection.creation.rate.Broker-wide connection rate limit should be configured based on broker capacity while listener limits should be configured based on application requirements.New connections will be throttled if either the listener or the broker limit is reached, with the exception of inter-broker listener.Connections on the inter-broker listener will be throttled only when the listener-level rate limit is reached.
broker.documentation.max.connections=The maximum number of connections we allow in the broker at any time.This limit is applied in addition to any per-ip limits configured using max.connections.per.ip.Listener-level limits may also be configured by prefixing the config name with the listener prefix, for example,listener.name.internal.max.connections.per.ip.Broker-wide limit should be configured based on broker capacity while listener limits should be configured based on application requirements.New connections are blocked if either the listener or broker limit is reached.Connections on the inter-broker listener are permitted even if broker-wide limit is reached.The least recently used connection on another listener will be closed in this case.
broker.documentation.max.connections.per.ip=The maximum number of connections we allow from each ip address.This can be set to 0 if there are overrides configured using max.connections.per.ip.overrides property.New connections from the ip address are dropped if the limit is reached.
broker.documentation.max.connections.per.ip.overrides=This configuration property lets you set specific overrides for the maximum number of connections allowed from individual IP addresses or hostnames.It’s a comma-separated list, where each entry specifies an IP address or hostname and its corresponding connection limit.An example value is “hostName:100,127.0.0.1:200”When using this property:
broker.documentation.max.incremental.fetch.session.cache.slots=The maximum number of total incremental fetch sessions that we will maintain.FetchSessionCache is sharded into 8 shards and the limit is equally divided among all shards.Sessions are allocated to each shard in round-robin.Only entries within a shard are considered eligible for eviction.
broker.documentation.max.request.partition.size.limit=The maximum number of partitions can be served in one request.
broker.documentation.num.partitions=The default number of log partitions per topic
broker.documentation.principal.builder.class=The fully qualified name of a class that implements the KafkaPrincipalBuilder interface, which is used to build the KafkaPrincipal object used during authorization.If no principal builder is defined, the default behavior depends on the security protocol in use.For SSL authentication,  the principal will be derived using the rules defined byssl.principal.mapping.rulesapplied on the distinguished name from the client certificate if one is provided; otherwise, if client authentication is not required, the principal name will be ANONYMOUS.For SASL authentication, the principal will be derived using the rules defined bysasl.kerberos.principal.to.local.rulesif GSSAPI is in use, and the SASL authentication ID for other mechanisms.For PLAINTEXT, the principal will be ANONYMOUS.Note that custom implementations ofKafkaPrincipalBuilderis required to implementKafkaPrincipalSerdeinterface, otherwise brokers will not be able to forward requests to the controller.
broker.documentation.producer.purgatory.purge.interval.requests=The purge interval (in number of requests) of the producer request purgatory
broker.documentation.queued.max.request.bytes=The number of queued bytes allowed before no more requests are read
broker.documentation.remote.fetch.max.wait.ms=The maximum amount of time the server will wait before answering the remote fetch request
broker.documentation.remote.list.offsets.request.timeout.ms=The maximum amount of time the server will wait for the remote list offsets request to complete.
broker.documentation.remote.log.manager.copy.max.bytes.per.second=The maximum number of bytes that can be copied from local storage to remote storage per second.This is a global limit for all the partitions that are being copied from local storage to remote storage.The default value is Long.MAX_VALUE, which means there is no limit on the number of bytes that can be copied per second.
broker.documentation.remote.log.manager.copy.quota.window.num=The number of samples to retain in memory for remote copy quota management.The default value is 11, which means there are 10 whole windows + 1 current window.
broker.documentation.remote.log.manager.copy.quota.window.size.seconds=The time span of each sample for remote copy quota management.The default value is 1 second.
broker.documentation.remote.log.manager.fetch.max.bytes.per.second=The maximum number of bytes that can be fetched from remote storage to local storage per second.This is a global limit for all the partitions that are being fetched from remote storage to local storage.The default value is Long.MAX_VALUE, which means there is no limit on the number of bytes that can be fetched per second.
broker.documentation.remote.log.manager.fetch.quota.window.num=The number of samples to retain in memory for remote fetch quota management.The default value is 11, which means there are 10 whole windows + 1 current window.
broker.documentation.remote.log.manager.fetch.quota.window.size.seconds=The time span of each sample for remote fetch quota management.The default value is 1 second.
broker.documentation.replica.fetch.backoff.ms=The base amount of time to wait when fetch partition error occurs.The backoff increases exponentially for each consecutive failure up to replica.fetch.backoff.ms
broker.documentation.replica.fetch.max.bytes=The number of bytes of messages to attempt to fetch for each partition.This is not an absolute maximum, if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made.The maximum record batch size accepted by the broker is defined viamessage.max.bytes(broker config) ormax.message.bytes(topic config).
broker.documentation.replica.fetch.response.max.bytes=Maximum bytes expected for the entire fetch response.Records are fetched in batches, and if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made.As such, this is not an absolute maximum.The maximum record batch size accepted by the broker is defined viamessage.max.bytes(broker config) ormax.message.bytes(topic config).
broker.documentation.replica.selector.class=The fully qualified class name that implements ReplicaSelector.This is used by the broker to find the preferred read replica.By default, we use an implementation that returns the leader.
broker.documentation.sasl.client.callback.handler.class=The fully qualified name of a SASL client callback handler class that implements the AuthenticateCallbackHandler interface.
broker.documentation.sasl.enabled.mechanisms=The list of SASL mechanisms enabled in the Kafka server.The list may contain any mechanism for which a security provider is available.Only GSSAPI is enabled by default.
broker.documentation.sasl.jaas.config=JAAS login context parameters for SASL connections in the format used by JAAS configuration files.JAAS configuration file format is describedhere.The format for the value is:loginModuleClasscontrolFlag(optionName=optionValue)*;.For brokers, the config must be prefixed with listener prefix and SASL mechanism name in lower-case.For example, listener.name.sasl_ssl.scram-sha-256.sasl.jaas.config=com.example.ScramLoginModule required;
broker.documentation.sasl.kerberos.kinit.cmd=Kerberos kinit command path.
broker.documentation.sasl.kerberos.min.time.before.relogin=Login thread sleep time between refresh attempts.
broker.documentation.sasl.kerberos.principal.to.local.rules=A list of rules for mapping from principal names to short names (typically operating system usernames).The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name.Any later rules in the list are ignored.By default, principal names of the form{username}/{hostname}@{REALM}are mapped to{username}.For more details on the format please see security authorization and acls.Note that this configuration is ignored if an extension ofKafkaPrincipalBuilderis provided by theprincipal.builder.classconfiguration.
broker.documentation.sasl.kerberos.service.name=The Kerberos principal name that Kafka runs as.This can be defined either in Kafka’s JAAS config or in Kafka’s config.
broker.documentation.sasl.kerberos.ticket.renew.jitter=Percentage of random jitter added to the renewal time.
broker.documentation.sasl.kerberos.ticket.renew.window.factor=Login thread will sleep until the specified window factor of time from last refresh to ticket’s expiry has been reached, at which time it will try to renew the ticket.
broker.documentation.sasl.login.callback.handler.class=The fully qualified name of a SASL login callback handler class that implements the AuthenticateCallbackHandler interface.For brokers, login callback handler config must be prefixed with listener prefix and SASL mechanism name in lower-case.For example, listener.name.sasl_ssl.scram-sha-256.sasl.login.callback.handler.class=com.example.CustomScramLoginCallbackHandler
broker.documentation.sasl.login.class=The fully qualified name of a class that implements the Login interface.For brokers, login config must be prefixed with listener prefix and SASL mechanism name in lower-case.For example, listener.name.sasl_ssl.scram-sha-256.sasl.login.class=com.example.CustomScramLogin
broker.documentation.sasl.login.refresh.buffer.seconds=The amount of buffer time before credential expiration to maintain when refreshing a credential, in seconds.If a refresh would otherwise occur closer to expiration than the number of buffer seconds then the refresh will be moved up to maintain as much of the buffer time as possible.Legal values are between 0 and 3600 (1 hour); a default value of  300 (5 minutes) is used if no value is specified.This value and sasl.login.refresh.min.period.seconds are both ignored if their sum exceeds the remaining lifetime of a credential.Currently applies only to OAUTHBEARER.
broker.documentation.sasl.login.refresh.min.period.seconds=The desired minimum time for the login refresh thread to wait before refreshing a credential, in seconds.Legal values are between 0 and 900 (15 minutes); a default value of 60 (1 minute) is used if no value is specified. This value and  sasl.login.refresh.buffer.seconds are both ignored if their sum exceeds the remaining lifetime of a credential.Currently applies only to OAUTHBEARER.
broker.documentation.sasl.login.refresh.window.factor=Login refresh thread will sleep until the specified window factor relative to the credential’s lifetime has been reached, at which time it will try to refresh the credential.Legal values are between 0.5 (50%) and 1.0 (100%) inclusive; a default value of 0.8 (80%) is used if no value is specified.Currently applies only to OAUTHBEARER.
broker.documentation.sasl.login.refresh.window.jitter=The maximum amount of random jitter relative to the credential’s lifetime that is added to the login refresh thread’s sleep time.Legal values are between 0 and 0.25 (25%) inclusive; a default value of 0.05 (5%) is used if no value is specified.Currently applies only to OAUTHBEARER.
broker.documentation.sasl.mechanism.inter.broker.protocol=SASL mechanism used for inter-broker communication.Default is GSSAPI.
broker.documentation.sasl.oauthbearer.jwks.endpoint.url=The OAuth/OIDC provider URL from which the provider’sJWKS (JSON Web Key Set)can be retrieved.The URL can be HTTP(S)-based or file-based.If the URL is HTTP(S)-based, the JWKS data will be retrieved from the OAuth/OIDC provider via the configured URL on broker startup.All then-current keys will be cached on the broker for incoming requests.If an authentication request is received for a JWT that includes a “kid” header claim value that isn’t yet in the cache, the JWKS endpoint will be queried again on demand.However, the broker polls the URL every sasl.oauthbearer.jwks.endpoint.refresh.ms milliseconds to refresh the cache with any forthcoming keys before any JWT requests that include them are received.If the URL is file-based, the broker will load the JWKS file from a configured location on startup.In the event that the JWT includes a “kid” header value that isn’t in the JWKS file, the broker will reject the JWT and authentication will fail.
broker.documentation.sasl.oauthbearer.token.endpoint.url=The URL for the OAuth/OIDC identity provider.If the URL is HTTP(S)-based, it is the issuer’s token endpoint URL to which requests will be made to login based on the configuration in sasl.jaas.config.If the URL is file-based, it specifies a file containing an access token (in JWT serialized form) issued by the OAuth/OIDC identity provider to use for authorization.
broker.documentation.sasl.server.authn.async.enable=Setting this configuration to true allows the SASL authentication to attempt to perform authentication asynchronously.
broker.documentation.sasl.server.authn.async.max.threads=Maximum number of threads in async authentication thread pool to perform authentication asynchronously.
broker.documentation.sasl.server.authn.async.timeout.ms=The broker will attempt to forcibly stop authentication that runs longer than this.
broker.documentation.sasl.server.callback.handler.class=The fully qualified name of a SASL server callback handler class that implements the AuthenticateCallbackHandler interface.Server callback handlers must be prefixed with listener prefix and SASL mechanism name in lower-case.For example, listener.name.sasl_ssl.plain.sasl.server.callback.handler.class=com.example.CustomPlainCallbackHandler.
broker.documentation.sasl.server.max.receive.size=The maximum receive size allowed before and during initial SASL authentication.Default receive size is 512KB.GSSAPI limits requests to 64K, but we allow upto 512KB by default for custom SASL mechanisms.In practice, PLAIN, SCRAM and OAUTH mechanisms can use much smaller limits.
broker.documentation.security.inter.broker.protocol=Security protocol used to communicate between brokers.It is an error to set this and inter.broker.listener.name properties at the same time.
broker.documentation.share.coordinator.append.linger.ms=The duration in milliseconds that the share coordinator will wait for writes to accumulate before flushing them to disk.
broker.documentation.share.coordinator.snapshot.update.records.per.snapshot=The number of update records the share coordinator writes between snapshot records.
broker.documentation.share.coordinator.threads=The number of threads used by the share coordinator.
broker.documentation.share.fetch.purgatory.purge.interval.requests=The purge interval (in number of requests) of the share fetch request purgatory
broker.documentation.socket.connection.setup.timeout.max.ms=The maximum amount of time the client will wait for the socket connection to be established.The connection setup timeout will increase exponentially for each consecutive connection failure up to this maximum.To avoid connection storms, a randomization factor of 0.2 will be applied to the timeout resulting in a random range between 20% below and 20% above the computed value.
broker.documentation.socket.connection.setup.timeout.ms=The amount of time the client will wait for the socket connection to be established.If the connection is not built before the timeout elapses, clients will close the socket channel.This value is the initial backoff value and will increase exponentially for each consecutive connection failure, up to thesocket.connection.setup.timeout.max.msvalue.
broker.documentation.socket.listen.backlog.size=The maximum number of pending connections on the socket.In Linux, you may also need to configuresomaxconnandtcp_max_syn_backlogkernel parameters accordingly to make the configuration takes effect.
broker.documentation.ssl.cipher.suites=A list of cipher suites.This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol.By default all the available cipher suites are supported.
broker.documentation.ssl.client.auth=Configures kafka broker to request client authentication.The following settings are common:
broker.documentation.ssl.enabled.protocols=The list of protocols enabled for SSL connections.The default is ‘TLSv1.2,TLSv1.3’.This means that clients and servers will prefer TLSv1.3 if both support it and fallback to TLSv1.2 otherwise (assuming both support at least TLSv1.2).This default should be fine for most use cases.Also see the config documentation forssl.protocolto understand how it can impact the TLS version negotiation behavior.
broker.documentation.ssl.key.password=The password of the private key in the key store file or the PEM key specified in ‘ssl.keystore.key’.
broker.documentation.ssl.keymanager.algorithm=The algorithm used by key manager factory for SSL connections.Default value is the key manager factory algorithm configured for the Java Virtual Machine.
broker.documentation.ssl.keystore.certificate.chain=Certificate chain in the format specified by ‘ssl.keystore.type’.Default SSL engine factory supports only PEM format with a list of X.509 certificates
broker.documentation.ssl.keystore.key=Private key in the format specified by ‘ssl.keystore.type’.Default SSL engine factory supports only PEM format with PKCS#8 keys.If the key is encrypted, key password must be specified using ‘ssl.key.password’
broker.documentation.ssl.keystore.location=The location of the key store file.This is optional for client and can be used for two-way authentication for client.
broker.documentation.ssl.keystore.password=The store password for the key store file.This is optional for client and only needed if ‘ssl.keystore.location’ is configured.Key store password is not supported for PEM format.
broker.documentation.ssl.keystore.type=The file format of the key store file.This is optional for client.The values currently supported by the defaultssl.engine.factory.classare [JKS, PKCS12, PEM].
broker.documentation.ssl.protocol=The SSL protocol used to generate the SSLContext.The default is ‘TLSv1.3’, which should be fine for most use cases.A typical alternative to the default is ‘TLSv1.2’.Allowed values for this config are dependent on the JVM.Clients using the defaults for this config and ‘ssl.enabled.protocols’ will downgrade to ‘TLSv1.2’ if the server does not support ‘TLSv1.3’.If this config is set to ‘TLSv1.2’, however, clients will not use ‘TLSv1.3’ even if it is one of the values inssl.enabled.protocolsand the server only supports ‘TLSv1.3’.
broker.documentation.ssl.provider=The name of the security provider used for SSL connections.Default value is the default security provider of the JVM.
broker.documentation.ssl.trustmanager.algorithm=The algorithm used by trust manager factory for SSL connections.Default value is the trust manager factory algorithm configured for the Java Virtual Machine.
broker.documentation.ssl.truststore.certificates=Trusted certificates in the format specified by ‘ssl.truststore.type’.Default SSL engine factory supports only PEM format with X.509 certificates.
broker.documentation.ssl.truststore.location=The location of the trust store file.
broker.documentation.ssl.truststore.password=The password for the trust store file.If a password is not set, trust store file configured will still be used, but integrity checking is disabled.Trust store password is not supported for PEM format.
broker.documentation.ssl.truststore.type=The file format of the trust store file.The values currently supported by the defaultssl.engine.factory.classare [JKS, PKCS12, PEM].
broker.documentation.transaction.metadata.load.threads=The number of threads that are used to concurrently load transaction metadata.
broker.documentation.alter.config.policy.class.name=The alter configs policy class that should be used for validation.The class should implement theorg.apache.kafka.server.policy.AlterConfigPolicyinterface.
broker.documentation.alter.log.dirs.replication.quota.window.num=The number of samples to retain in memory for alter log dirs replication quotas
broker.documentation.alter.log.dirs.replication.quota.window.size.seconds=The time span of each sample for alter log dirs replication quotas
broker.documentation.authorizer.class.name=The fully qualified name of a class that implementsorg.apache.kafka.server.authorizer.Authorizerinterface, which is used by the broker for authorization.
broker.documentation.client.quota.callback.class=The fully qualified name of a class that implements the ClientQuotaCallback interface, which is used to determine quota limits applied to client requests.For any given request, the most specific quota that matches the user principal of the session and the client-id of the request is applied.
broker.documentation.client.quota.max.throttle.time.in.response.ms=The max time in ms to be set in a produce response if a client hits the client produce bandwidth quota.
broker.documentation.client.quota.max.throttle.time.ms=The time period in ms upto which a client is throttled (the corresponding channel is muted on broker side), if it hits the client produce bandwidth quota.
broker.documentation.confluent.authorizer.authority.name=The DNS name of the authority that this clusteruses to authorize.This should be a name for the cluster hosting metadata topics.
broker.documentation.confluent.cluster.link.allow.legacy.message.format=Whether or not to allow mirroring v0/v1 messages into the topic
broker.documentation.confluent.cluster.link.local.reverse.connection.listener.map=A map from listener name to listener name for configuring the cluster link local.listener.name, which is used to establish local end of reverse connections.
broker.documentation.confluent.cluster.link.max.client.connections=The maximum number of active cluster linking client connections allowed on the broker.
broker.documentation.confluent.cluster.link.num.background.threads=Maximum number of threads used for cluster linking background tasks including periodic migration of metadata.
broker.documentation.confluent.cluster.link.replication.quota.mode=The default mode for cluster link quota for all tenants that applies to ‘confluent.cluster.link.io.max.bytes.per.second’ if not overridden by confluent.cluster.link.replication.quota.mode.per.tenant.overrides.The mode indicates which inbound traffic is counted towards the limit.Valid values are ‘CLUSTER_LINK_ONLY’ and ‘TOTAL_INBOUND’.
broker.documentation.confluent.cluster.link.replication.quota.window.num=The number of samples to retain in memory for cluster link replication quotas
broker.documentation.confluent.cluster.link.replication.quota.window.size.seconds=The time span of each sample for cluster link replication quotas
broker.documentation.confluent.cluster.link.request.quota.capacity=The total capacity i.e.broker quota limit for the total amount of time cluster link requests can spend on fetcher and background threads if tenant quotas are enabled.This is configured as total percentage of CPU i.e.a value of 400 means cluster link can use up to 4 CPUs.
broker.documentation.confluent.defer.isr.shrink.enable=Defer ISR shrinking for partitions that only have messages with acks=“all” if shrinking ISR would make partition fall under min ISR.
broker.documentation.confluent.log.placement.constraints=This configuration is a JSON object that controls the set of brokers (replicas) which will always be allowed to join the ISR.And the set of brokers (observers) which are not allowed to join the ISR.The format of JSON is:{  “version”: 1,  “replicas”: [    {      “count”: 2,      “constraints”: {“rack”: “east-1”}    },    {      “count”: 1,      “constraints”: {“rack”: “east-2”}    }  ],  “observers”:[    {      “count”: 1,      “constraints”: {“rack”: “west-1”}    }  ]}
broker.documentation.confluent.metadata.server.cluster.registry.clusters=JSON defining initial state of Cluster Registry.This should not be set manually, instead Cluster Registry http apis should be used.
broker.documentation.confluent.reporters.telemetry.auto.enable=Auto-enable telemetry on the broker.This will add the telemetry reporter to the broker’s ‘metric.reporters’ property if it is not already present.Disabling this property will prevent Self-balancing Clusters from working properly.
broker.documentation.confluent.schema.registry.url=Comma-separated list of URLs for schema registry instances that can be used to look up schemas.
broker.documentation.confluent.security.event.router.config=JSON configuration for routing events to topics
broker.documentation.confluent.telemetry.enabled=True if telemetry data can to be reported to Confluent Cloud
broker.documentation.confluent.telemetry.external.client.metrics.delta.temporality=False if delta temporality should be disabled for telemetry metrics
broker.documentation.confluent.telemetry.external.client.metrics.push.enabled=True if client metrics are enabled, which can to be reported to Confluent Cloud
broker.documentation.confluent.tier.fenced.segment.delete.delay.ms=Segments uploaded by fenced leaders may still be being uploaded when retention occurs on a newly elected leader.Storage backends like AWS S3 return success for delete operations if the object is not found, so to address this edge case the deletion of segments uploaded by fenced leaders is delayed byconfluent.tier.fenced.segment.delete.delay.mswith the assumption that the upload will be completed by the time the deletion occurs.
broker.documentation.confluent.tier.gcs.cred.file.path=The path to the credentials file used to create the GCS client.This uses the default GCS configuration file format; please refer to GCP documentation on how to generate the credentials file.If not specified, the GCS client will be instantiated using the default service account available.
broker.documentation.confluent.tier.s3.aws.endpoint.override=Override picking an S3 endpoint.Normally this is performed automatically by the client.
broker.documentation.confluent.tier.s3.cred.file.path=The path to the credentials file used to create the S3 client.It uses a Java properties file and extracts the AWS access key from the “accessKey” property and AWS secret access key from the “secretKey” property.Please refer to AWS documentation for further information.If this property is not specified, the S3 client will use theDefaultAWSCredentialsProviderChainto locate the credentials.
broker.documentation.confluent.tier.s3.force.path.style.access=Configures the client to use path-style access for all requests.This flag is not enabled by default.The default behavior is to detect which access style to use based on the configured endpoint and the bucket being accessed.Setting this flag will result in path-style access being forced for all requests.
broker.documentation.confluent.tier.s3.security.providers=One or more comma separated security providers to be used.
broker.documentation.confluent.tier.s3.ssl.enabled.protocols=The list of protocols enabled for SSL connections.The default is ‘TLSv1.2,TLSv1.3’ when running with Java 11 or newer, ‘TLSv1.2’ otherwise.
broker.documentation.confluent.tier.s3.ssl.key.password=Key password when using TLS connectivity to AWS S3.Overrides any explicit value set via thejavax.net.ssl.keyPasswordsystem property (note the camelCase).
broker.documentation.confluent.tier.s3.ssl.keystore.location=Keystore location when using TLS connectivity to AWS S3.Overrides any explicit value set via thejavax.net.ssl.keyStoresystem property (note the camelCase).
broker.documentation.confluent.tier.s3.ssl.keystore.password=Keystore password when using TLS connectivity to AWS S3.Overrides any explicit value set via thejavax.net.ssl.keyStorePasswordsystem property (note the camelCase).
broker.documentation.confluent.tier.s3.ssl.keystore.type=Keystore type when using TLS connectivity to AWS S3.Overrides any explicit value set via thejavax.net.ssl.keyStoreTypesystem property (note the camelCase).
broker.documentation.confluent.tier.s3.ssl.protocol=The SSL protocol used to generate the SSLContext.The default is ‘TLSv1.3’ when running with Java 11 or newer, ‘TLSv1.2’ otherwise.
broker.documentation.confluent.tier.s3.ssl.provider=SSL provider to use for the client when connecting to AWS S3.
broker.documentation.confluent.tier.s3.ssl.truststore.location=Truststore location when using TLS connectivity to AWS S3.Overrides any explicit value set via thejavax.net.ssl.trustStoresystem property (note the camelCase).
broker.documentation.confluent.tier.s3.ssl.truststore.password=Truststore password when using TLS connectivity to AWS S3.Overrides any explicit value set via thejavax.net.ssl.trustStorePasswordsystem property (note the camelCase).
broker.documentation.confluent.tier.s3.ssl.truststore.type=Truststore type when using TLS connectivity to AWS S3.Overrides any explicit value set via thejavax.net.ssl.trustStoreTypesystem property (note the camelCase).
broker.documentation.confluent.tier.s3.storage.class.override=Storage class to use when uploading tier objects to S3.The acceptable values are “STANDARD_IA” and “”.Please do not set this property when using AWS S3, as it may have adverse/extreme impact on costs.The STANDARD_IA class is supported purely for the purpose of compatibility with other S3-compatible object stores, you have to evaluate the impact on costs specific to the implementation.When the value is left empty, tiered storage will use the default S3 storage class as provided by the object store implementation (note: in the case of AWS S3, the default is STANDARD storage class).The remaining storage classes are unavailable at this point.
broker.documentation.confluent.tier.topic.delete.backoff.ms=Maximum amount of time to wait before deleting tiered objects for a deleted partition.
broker.documentation.confluent.tier.topic.delete.check.interval.ms=Frequency at which tiered objects cleanup is run for deleted topics.
broker.documentation.confluent.tier.topic.delete.max.inprogress.partitions=Maximum number of partitions deleted from remote storage in the deletion interval defined byconfluent.tier.topic.delete.check.interval.ms
broker.documentation.connection.failed.authentication.delay.ms=Connection close delay on failed authentication: this is the time (in milliseconds) by which connection close will be delayed on authentication failure.This must be configured to be less than connections.max.idle.ms to prevent connection timeout.
broker.documentation.controller.quorum.retry.backoff.ms=The amount of time to wait before attempting to retry a failed request to a given topic partition.This avoids repeatedly sending requests in a tight loop under some failure scenarios.This value is the initial backoff value and will increase exponentially for each failed request, up to theretry.backoff.max.msvalue.
broker.documentation.controller.quota.window.num=The number of samples to retain in memory for controller mutation quotas
broker.documentation.controller.quota.window.size.seconds=The time span of each sample for controller mutations quotas
broker.documentation.create.topic.policy.class.name=The create topic policy class that should be used for validation.The class should implement theorg.apache.kafka.server.policy.CreateTopicPolicyinterface.
broker.documentation.delegation.token.expiry.check.interval.ms=Scan interval to remove expired delegation tokens.
broker.documentation.enable.fips=Enable FIPS mode on the server.If FIPS mode is enabled, broker listener security protocols, TLS versions and cipher suites will be validated based on FIPS compliance requirement.
broker.documentation.follower.replication.throttled.rate=A long representing the upper bound (bytes/sec) on replication traffic for followers enumerated in the property follower.replication.throttled.replicas (for each topic).This property can be only set dynamically.It is suggested that the limit be kept above 1MB/s for accurate behaviour.
broker.documentation.follower.replication.throttled.replicas=A list of replicas for which log replication should be throttled on the follower side.The list should describe a set of replicas in the form [PartitionId]:[BrokerId],[PartitionId]:[BrokerId]:… or alternatively the wildcard ‘*’ can be used to throttle all replicas for this topic.
broker.documentation.kafka.metrics.polling.interval.secs=The metrics polling interval (in seconds) which can be used in kafka.metrics.reporters implementations.
broker.documentation.kafka.metrics.reporters=A list of classes to use as Yammer metrics custom reporters.The reporters should implementkafka.metrics.KafkaMetricsReportertrait.If a client wants to expose JMX operations on a custom reporter, the custom reporter needs to additionally implement an MBean trait that extendskafka.metrics.KafkaMetricsReporterMBeantrait so that the registered MBean is compliant with the standard MBean convention.
broker.documentation.leader.replication.throttled.rate=A long representing the upper bound (bytes/sec) on replication traffic for leaders enumerated in the property leader.replication.throttled.replicas (for each topic).This property can be only set dynamically.It is suggested that the limit be kept above 1MB/s for accurate behaviour.
broker.documentation.leader.replication.throttled.replicas=A list of replicas for which log replication should be throttled on the leader side.The list should describe a set of replicas in the form [PartitionId]:[BrokerId],[PartitionId]:[BrokerId]:… or alternatively the wildcard ‘*’ can be used to throttle all replicas for this topic.
broker.documentation.listener.security.protocol.map=Map between listener names and security protocols.This must be defined for the same security protocol to be usable in more than one port or IP.For example, internal and external traffic can be separated even if SSL is required for both.Concretely, the user could define listeners with names INTERNAL and EXTERNAL and this property as:INTERNAL:SSL,EXTERNAL:SSL.As shown, key and value are separated by a colon and map entries are separated by commas.Each listener name should only appear once in the map.Different security (SSL and SASL) settings can be configured for each listener by adding a normalised prefix (the listener name is lowercased) to the config name.For example, to set a different keystore for the INTERNAL listener, a config with namelistener.name.internal.ssl.keystore.locationwould be set.If the config for the listener name is not set, the config will fallback to the generic config (i.e.ssl.keystore.location).Note that in KRaft a default mapping from the listener names defined bycontroller.listener.namesto PLAINTEXT is assumed if no explicit mapping is provided and no other security protocol is in use.
broker.documentation.log.dir.failure.timeout.ms=If the broker is unable to successfully communicate to the controller that some log directory has failed for longer than this time, the broker will fail and shut down.
broker.documentation.metadata.max.idle.interval.ms=This configuration controls how often the active controller should write no-op records to the metadata partition.If the value is 0, no-op records are not appended to the metadata partition.The default value is 500
broker.documentation.metric.reporters=A list of classes to use as metrics reporters.Implementing theorg.apache.kafka.common.metrics.MetricsReporterinterface allows plugging in classes that will be notified of new metric creation.
broker.documentation.metrics.num.samples=The number of samples maintained to compute metrics.
broker.documentation.metrics.recording.level=The highest recording level for metrics.It has three levels for recording metrics - info, debug, and trace.INFO level records only essential metrics necessary for monitoring system performance and health.It collects vital data without gathering too much detail, making it suitable for production environments where minimal overhead is desired.DEBUG level records most metrics, providing more detailed information about the system’s operation.It’s useful for development and testing environments where you need deeper insights to debug and fine-tune the application.TRACE level records all possible metrics, capturing every detail about the system’s performance and operation.It’s best for controlled environments where in-depth analysis is required, though it can introduce significant overhead.
broker.documentation.metrics.sample.window.ms=The window of time a metrics sample is computed over.
broker.documentation.producer.id.expiration.ms=The time in ms that a topic partition leader will wait before expiring producer IDs.Producer IDs will not expire while a transaction associated to them is still ongoing.Note that producer IDs may expire sooner if the last write from the producer ID is deleted due to the topic’s retention settings.Setting this value the same or higher thandelivery.timeout.mscan help prevent expiration during retries and protect against message duplication, but the default should be reasonable for most use cases.
broker.documentation.quota.window.num=The number of samples to retain in memory for client quotas
broker.documentation.quota.window.size.seconds=The time span of each sample for client quotas
broker.documentation.remote.log.index.file.cache.total.size.bytes=The total size of the space allocated to store index files fetched from remote storage in the local storage.
broker.documentation.replication.quota.window.num=The number of samples to retain in memory for replication quotas
broker.documentation.replication.quota.window.size.seconds=The time span of each sample for replication quotas
broker.documentation.sasl.login.connect.timeout.ms=The (optional) value in milliseconds for the external authentication provider connection timeout.Currently applies only to OAUTHBEARER.
broker.documentation.sasl.login.read.timeout.ms=The (optional) value in milliseconds for the external authentication provider read timeout.Currently applies only to OAUTHBEARER.
broker.documentation.sasl.login.retry.backoff.max.ms=The (optional) value in milliseconds for the maximum wait between login attempts to the external authentication provider.Login uses an exponential backoff algorithm with an initial wait based on the sasl.login.retry.backoff.ms setting and will double in wait length between attempts up to a maximum wait length specified by the sasl.login.retry.backoff.max.ms setting.Currently applies only to OAUTHBEARER.
broker.documentation.sasl.login.retry.backoff.ms=The (optional) value in milliseconds for the initial wait between login attempts to the external authentication provider.Login uses an exponential backoff algorithm with an initial wait based on the sasl.login.retry.backoff.ms setting and will double in wait length between attempts up to a maximum wait length specified by the sasl.login.retry.backoff.max.ms setting.Currently applies only to OAUTHBEARER.
broker.documentation.sasl.oauthbearer.assertion.claim.aud=The value to be added to the Audience claim “aud” which will be included in the client assertion created locally
broker.documentation.sasl.oauthbearer.assertion.claim.exp.minutes=The (Optional) expiration time for the client assertion in minutesThe default value is 5 minutes
broker.documentation.sasl.oauthbearer.assertion.claim.iss=The value to be added to the Issuer claim “iss” which will be included in the client assertion created locally
broker.documentation.sasl.oauthbearer.assertion.claim.jti.include=The (optional) setting for specifying whether to include jti claim or not
broker.documentation.sasl.oauthbearer.assertion.claim.nbf.include=The (optional) setting for specifying whether to include “not before” (nbf) claim or notIf set to true, nbf claim with (current time - 1 minute) will be included in the client assertion
broker.documentation.sasl.oauthbearer.assertion.claim.sub=The value to be added to the Subject claim “sub” which will be included in the client assertion created locally
broker.documentation.sasl.oauthbearer.assertion.file=The location/path on disc at which a signed client assertion is presentThis will be passed directly to the token endpoint.
broker.documentation.sasl.oauthbearer.assertion.private.key.file=The location for the private key to be used for signing client assertion in PEM formatRequired for local client assertion creation
broker.documentation.sasl.oauthbearer.assertion.private.key.passphrase=The passphrase required for decrypting the private key (in case of PKCS#8 format pem file)
broker.documentation.sasl.oauthbearer.assertion.template.file=The location for the JSON file which contains additional header and payload claims to be included in the client assertion
broker.documentation.sasl.oauthbearer.clock.skew.seconds=The (optional) value in seconds to allow for differences between the time of the OAuth/OIDC identity provider and the broker.
broker.documentation.sasl.oauthbearer.expected.audience=The (optional) comma-delimited setting for the broker to use to verify that the JWT was issued for one of the expected audiences.The JWT will be inspected for the standard OAuth “aud” claim and if this value is set, the broker will match the value from JWT’s “aud” claim  to see if there is an exact match.If there is no match, the broker will reject the JWT and authentication will fail.
broker.documentation.sasl.oauthbearer.expected.issuer=The (optional) setting for the broker to use to verify that the JWT was created by the expected issuer.The JWT will be inspected for the standard OAuth “iss” claim and if this value is set, the broker will match it exactly against what is in the JWT’s “iss” claim.If there is no match, the broker will reject the JWT and authentication will fail.
broker.documentation.sasl.oauthbearer.iat.validation.enabled=Setting this flag true, would mandate the presence ofiat(Issued At) claim in the token.However, there is no validation on the value of this field
broker.documentation.sasl.oauthbearer.jti.validation.enabled=Setting this flag true, would mandate the presence ofjti(JWT ID) claim in the token.However, there is no validation on the value of this field
broker.documentation.sasl.oauthbearer.jwks.endpoint.refresh.ms=The (optional) value in milliseconds for the broker to wait between refreshing its JWKS (JSON Web Key Set) cache that contains the keys to verify the signature of the JWT.
broker.documentation.sasl.oauthbearer.jwks.endpoint.retry.backoff.max.ms=The (optional) value in milliseconds for the maximum wait between attempts to retrieve the JWKS (JSON Web Key Set) from the external authentication provider.JWKS retrieval uses an exponential backoff algorithm with an initial wait based on the sasl.oauthbearer.jwks.endpoint.retry.backoff.ms setting and will double in wait length between attempts up to a maximum wait length specified by the sasl.oauthbearer.jwks.endpoint.retry.backoff.max.ms setting.
broker.documentation.sasl.oauthbearer.jwks.endpoint.retry.backoff.ms=The (optional) value in milliseconds for the initial wait between JWKS (JSON Web Key Set) retrieval attempts from the external authentication provider.JWKS retrieval uses an exponential backoff algorithm with an initial wait based on the sasl.oauthbearer.jwks.endpoint.retry.backoff.ms setting and will double in wait length between attempts up to a maximum wait length specified by the sasl.oauthbearer.jwks.endpoint.retry.backoff.max.ms setting.
broker.documentation.sasl.oauthbearer.scope.claim.name=The OAuth claim for the scope is often named “scope”, but this (optional) setting can provide a different name to use for the scope included in the JWT payload’s claims if the OAuth/OIDC provider uses a different name for that claim.
broker.documentation.sasl.oauthbearer.sub.claim.name=The OAuth claim for the subject is often named “sub”, but this (optional) setting can provide a different name to use for the subject included in the JWT payload’s claims if the OAuth/OIDC provider uses a different name for that claim.
broker.documentation.security.providers=A list of configurable creator classes each returning a provider implementing security algorithms.These classes should implement theorg.apache.kafka.common.security.auth.SecurityProviderCreatorinterface.
broker.documentation.ssl.allow.dn.changes=Indicates whether changes to the certificate distinguished name should be allowed during a dynamic reconfiguration of certificates or not.
broker.documentation.ssl.allow.san.changes=Indicates whether changes to the certificate subject alternative names should be allowed during a dynamic reconfiguration of certificates or not.
broker.documentation.ssl.endpoint.identification.algorithm=The endpoint identification algorithm to validate server hostname using server certificate.
broker.documentation.ssl.engine.factory.class=The class of type org.apache.kafka.common.security.auth.SslEngineFactory to provide SSLEngine objects.Default value is org.apache.kafka.common.security.ssl.DefaultSslEngineFactory.Alternatively, setting this to org.apache.kafka.common.security.ssl.CommonNameLoggingSslEngineFactory will log the common name of expired SSL certificates used by clients to authenticate at any of the brokers with log level INFO.Note that this will cause a tiny delay during establishment of new connections from mTLS clients to brokers due to the extra code for examining the certificate chain provided by the client.Note further that the implementation uses a custom truststore based on the standard Java truststore and thus might be considered a security risk due to not being as mature as the standard one.
broker.documentation.ssl.principal.mapping.rules=A list of rules for mapping from distinguished name from the client certificate to short name.The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name.Any later rules in the list are ignored.By default, distinguished name of the X.500 certificate will be the principal.For more details on the format please see security authorization and acls.Note that this configuration is ignored if an extension of KafkaPrincipalBuilder is provided by theprincipal.builder.classconfiguration.
broker.documentation.ssl.secure.random.implementation=The SecureRandom PRNG implementation to use for SSL cryptography operations.
broker.documentation.telemetry.max.bytes=The maximum size (after compression if compression is used) of telemetry metrics pushed from a client to the broker.The default value is 1048576 (1 MB).
broker.documentation.throughput.quota.window.num=The number of samples to retain in memory for produce and fetch quotas
broker.documentation.token.impersonation.validation=Indicates whether impersonation token validation should be enabled or not.If enabled, the broker will validate the incoming certificate subject with the cp_proxy claim in impersonation token.
broker.documentation.transaction.abort.timed.out.transaction.cleanup.interval.ms=The interval at which to rollback transactions that have timed out
broker.documentation.transaction.partition.verification.enable=Enable verification that checks that the partition has been added to the transaction before writing transactional records to the partition
broker.documentation.transaction.remove.expired.transaction.cleanup.interval.ms=The interval at which to remove transactions that have expired due totransactional.id.expiration.mspassing